
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>1.7. Gaussian Processes &mdash; scikit-learn 0.18.dev0 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.18.dev0 documentation" href="../index.html" />
    <link rel="up" title="1. Supervised learning" href="../supervised_learning.html" />
    <link rel="next" title="1.8. Cross decomposition" href="cross_decomposition.html" />
    <link rel="prev" title="1.6. Nearest Neighbors" href="neighbors.html" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/gaussian_process.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
  </script>

  </head>
  <body>

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../install.html">Installation</a></li>
                <li class="btn-li"><div class="btn-group">
              <a href="../documentation.html">Documentation</a>
              <a class="btn dropdown-toggle" data-toggle="dropdown">
                 <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
            <li class="link-title">Scikit-learn 0.17 (development)</li>
            <li><a href="../tutorial/index.html">Tutorials</a></li>
            <li><a href="../user_guide.html">User guide</a></li>
            <li><a href="classes.html">API</a></li>
            <li><a href="../faq.html">FAQ</a></li>
            <li><a href="../developers.html">Contributing</a></li>
            <li class="divider"></li>
                <li><a href="http://scikit-learn.org/stable/documentation.html">Scikit-learn 0.16.1 (stable)</a></li>
                <li><a href="http://scikit-learn.org/0.15/documentation.html">Scikit-learn 0.15</a></li>
				<li><a href="../_downloads/user_guide.pdf">PDF documentation</a></li>
              </ul>
            </div>
        </li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/scikit-learn/scikit-learn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="neighbors.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        1.6. Nearest Nei...
        </span>
            <span class="hiddenrellink">
            1.6. Nearest Neighbors
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../supervised_learning.html">
        Up
        <br/>
        <span class="smallrellink">
        1. Supervised le...
        </span>
            <span class="hiddenrellink">
            1. Supervised learning
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.18.dev0</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">1.7. Gaussian Processes</a><ul>
<li><a class="reference internal" href="#gaussian-process-regression-gpr">1.7.1. Gaussian Process Regression (GPR)</a></li>
<li><a class="reference internal" href="#gpr-examples">1.7.2. GPR examples</a><ul>
<li><a class="reference internal" href="#gpr-with-noise-level-estimation">1.7.2.1. GPR with noise-level estimation</a></li>
<li><a class="reference internal" href="#comparison-of-gpr-and-kernel-ridge-regression">1.7.2.2. Comparison of GPR and Kernel Ridge Regression</a></li>
<li><a class="reference internal" href="#gpr-on-mauna-loa-co2-data">1.7.2.3. GPR on Mauna Loa CO2 data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gaussian-process-classification-gpc">1.7.3. Gaussian Process Classification (GPC)</a></li>
<li><a class="reference internal" href="#gpc-examples">1.7.4. GPC examples</a><ul>
<li><a class="reference internal" href="#probabilistic-predictions-with-gpc">1.7.4.1. Probabilistic predictions with GPC</a></li>
<li><a class="reference internal" href="#illustration-of-gpc-on-the-xor-dataset">1.7.4.2. Illustration of GPC on the XOR dataset</a></li>
<li><a class="reference internal" href="#gaussian-process-classification-gpc-on-iris-dataset">1.7.4.3. Gaussian process classification (GPC) on iris dataset</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernels-for-gaussian-processes">1.7.5. Kernels for Gaussian Processes</a><ul>
<li><a class="reference internal" href="#gaussian-process-kernel-api">1.7.5.1. Gaussian Process Kernel API</a></li>
<li><a class="reference internal" href="#basic-kernels">1.7.5.2. Basic kernels</a></li>
<li><a class="reference internal" href="#kernel-operators">1.7.5.3. Kernel operators</a></li>
<li><a class="reference internal" href="#radial-basis-function-rbf-kernel">1.7.5.4. Radial-basis function (RBF) kernel</a></li>
<li><a class="reference internal" href="#matern-kernel">1.7.5.5. Matérn kernel</a></li>
<li><a class="reference internal" href="#rational-quadratic-kernel">1.7.5.6. Rational quadratic kernel</a></li>
<li><a class="reference internal" href="#exp-sine-squared-kernel">1.7.5.7. Exp-Sine-Squared kernel</a></li>
<li><a class="reference internal" href="#dot-product-kernel">1.7.5.8. Dot-Product kernel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#legacy-gaussian-processes">1.7.6. Legacy Gaussian Processes</a><ul>
<li><a class="reference internal" href="#an-introductory-regression-example">1.7.6.1. An introductory regression example</a></li>
<li><a class="reference internal" href="#fitting-noisy-data">1.7.6.2. Fitting Noisy Data</a></li>
<li><a class="reference internal" href="#mathematical-formulation">1.7.6.3. Mathematical formulation</a><ul>
<li><a class="reference internal" href="#the-initial-assumption">1.7.6.3.1. The initial assumption</a></li>
<li><a class="reference internal" href="#the-best-linear-unbiased-prediction-blup">1.7.6.3.2. The best linear unbiased prediction (BLUP)</a></li>
<li><a class="reference internal" href="#the-empirical-best-linear-unbiased-predictor-eblup">1.7.6.3.3. The empirical best linear unbiased predictor (EBLUP)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#correlation-models">1.7.6.4. Correlation Models</a></li>
<li><a class="reference internal" href="#regression-models">1.7.6.5. Regression Models</a></li>
<li><a class="reference internal" href="#implementation-details">1.7.6.6. Implementation details</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="gaussian-processes">
<span id="gaussian-process"></span><h1>1.7. Gaussian Processes<a class="headerlink" href="#gaussian-processes" title="Permalink to this headline">¶</a></h1>
<p><strong>Gaussian Processes (GP)</strong> are a generic supervised learning method designed
to solve <em>regression</em> and <em>probabilistic classification</em> problems.</p>
<p>The advantages of Gaussian processes are:</p>
<blockquote>
<div><ul class="simple">
<li>The prediction interpolates the observations (at least for regular
kernels).</li>
<li>The prediction is probabilistic (Gaussian) so that one can compute
empirical confidence intervals and decide based on those if one should
refit (online fitting, adaptive fitting) the prediction in some
region of interest.</li>
<li>Versatile: different <a class="reference internal" href="#gp-kernels"><em>kernels</em></a> can be specified. Common kernels are provided, but
it is also possible to specify custom kernels.</li>
</ul>
</div></blockquote>
<p>The disadvantages of Gaussian processes include:</p>
<blockquote>
<div><ul class="simple">
<li>They are not sparse, i.e., they use the whole samples/features information to
perform the prediction.</li>
<li>They lose efficiency in high dimensional spaces &#8211; namely when the number
of features exceeds a few dozens.</li>
</ul>
</div></blockquote>
<div class="section" id="gaussian-process-regression-gpr">
<span id="gpr"></span><h2>1.7.1. Gaussian Process Regression (GPR)<a class="headerlink" href="#gaussian-process-regression-gpr" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessRegressor.html#sklearn.gaussian_process.GaussianProcessRegressor" title="sklearn.gaussian_process.GaussianProcessRegressor"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcessRegressor</span></tt></a> implements Gaussian processes (GP) for
regression purposes. For this, the prior of the GP needs to be specified. The
prior mean is assumed to be constant and zero (for <tt class="docutils literal"><span class="pre">normalize_y=False</span></tt>) or the
training data&#8217;s mean (for <tt class="docutils literal"><span class="pre">normalize_y=True</span></tt>). The prior&#8217;s
covariance is specified by a passing a <a class="reference internal" href="#gp-kernels"><em>kernel</em></a> object. The
hyperparameters of the kernel are optimized during fitting of
GaussianProcessRegressor by maximizing the log-marginal-likelihood (LML) based
on the passed <tt class="docutils literal"><span class="pre">optimizer</span></tt>. As the LML may have multiple local optima, the
optimizer can be started repeatedly by specifying <tt class="docutils literal"><span class="pre">n_restarts_optimizer</span></tt>. The
first run is always conducted starting from the initial hyperparameter values
of the kernel; subsequent runs are conducted from hyperparameter values
that have been chosen randomly from the range of allowed values.
If the initial hyperparameters should be kept fixed, <cite>None</cite> can be passed as
optimizer.</p>
<p>The noise level in the targets can be specified by passing it via the
parameter <tt class="docutils literal"><span class="pre">alpha</span></tt>, either globally as a scalar or per datapoint.
Note that a moderate noise level can also be helpful for dealing with numeric
issues during fitting as it is effectively implemented as Tikhonov
regularization, i.e., by adding it to the diagonal of the kernel matrix. An
alternative to specifying the noise level explicitly is to include a
WhiteKernel component into the kernel, which can estimate the global noise
level from the data (see example below).</p>
<p>The implementation is based on Algorithm 2.1 of [RW2006]. In addition to
the API of standard sklearn estimators, GaussianProcessRegressor:</p>
<blockquote>
<div><ul class="simple">
<li>allows prediction without prior fitting (based on the GP prior)</li>
<li>provides an additional method <tt class="docutils literal"><span class="pre">sample_y(X)</span></tt>, which evaluates samples
drawn from the GPR (prior or posterior) at given inputs</li>
<li>exposes a method <tt class="docutils literal"><span class="pre">log_marginal_likelihood(theta)</span></tt>, which can be used
externally for other ways of selecting hyperparameters, e.g., via
Markov chain Monte Carlo.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="gpr-examples">
<h2>1.7.2. GPR examples<a class="headerlink" href="#gpr-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="gpr-with-noise-level-estimation">
<h3>1.7.2.1. GPR with noise-level estimation<a class="headerlink" href="#gpr-with-noise-level-estimation" title="Permalink to this headline">¶</a></h3>
<p>This example illustrates that GPR with a sum-kernel including a WhiteKernel can
estimate the noise level of data. An illustration of the
log-marginal-likelihood (LML) landscape shows that there exist two local
maxima of LML.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="../_images/plot_gpr_noisy_0001.png" src="../_images/plot_gpr_noisy_0001.png" /></a>
</div>
<p>The first corresponds to a model with a high noise level and a
large length scale, which explains all variations in the data by noise.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="../_images/plot_gpr_noisy_0011.png" src="../_images/plot_gpr_noisy_0011.png" /></a>
</div>
<p>The second one has a smaller noise level and shorter length scale, which explains
most of the variation by the noise-free functional relationship. The second
model has a higher likelihood; however, depending on the initial value for the
hyperparameters, the gradient-based optimization might also converge to the
high-noise solution. It is thus important to repeat the optimization several
times for different initializations.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_noisy.html"><img alt="../_images/plot_gpr_noisy_0021.png" src="../_images/plot_gpr_noisy_0021.png" /></a>
</div>
</div>
<div class="section" id="comparison-of-gpr-and-kernel-ridge-regression">
<h3>1.7.2.2. Comparison of GPR and Kernel Ridge Regression<a class="headerlink" href="#comparison-of-gpr-and-kernel-ridge-regression" title="Permalink to this headline">¶</a></h3>
<p>Both kernel ridge regression (KRR) and GPR learn
a target function by employing internally the &#8220;kernel trick&#8221;. KRR learns a
linear function in the space induced by the respective kernel which corresponds
to a non-linear function in the original space. The linear function in the
kernel space is chosen based on the mean-squared error loss with
ridge regularization. GPR uses the kernel to define the covariance of
a prior distribution over the target functions and uses the observed training
data to define a likelihood function. Based on Bayes theorem, a (Gaussian)
posterior distribution over target functions is defined, whose mean is used
for prediction.</p>
<p>A major difference is that GPR can choose the kernel&#8217;s hyperparameters based
on gradient-ascent on the marginal likelihood function while KRR needs to
perform a grid search on a cross-validated loss function (mean-squared error
loss). A further difference is that GPR learns a generative, probabilistic
model of the target function and can thus provide meaningful confidence
intervals and posterior samples along with the predictions while KRR only
provides predictions.</p>
<p>The following figure illustrates both methods on an artificial dataset, which
consists of a sinusoidal target function and strong noise. The figure compares
the learned model of KRR and GPR based on a ExpSineSquared kernel, which is
suited for learning periodic functions. The kernel&#8217;s hyperparameters control
the smoothness (length_scale) and periodicity of the kernel (periodicity).
Moreover, the noise level
of the data is learned explicitly by GPR by an additional WhiteKernel component
in the kernel and by the regularization parameter alpha of KRR.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_compare_gpr_krr.html"><img alt="../_images/plot_compare_gpr_krr_0011.png" src="../_images/plot_compare_gpr_krr_0011.png" /></a>
</div>
<p>The figure shows that both methods learn reasonable models of the target
function. GPR correctly identifies the periodicity of the function to be
roughly <span class="math">2*\pi</span> (6.28), while KRR chooses the doubled periodicity
<span class="math">4*\pi</span> . Besides
that, GPR provides reasonable confidence bounds on the prediction which are not
available for KRR. A major difference between the two methods is the time
required for fitting and predicting: while fitting KRR is fast in principle,
the grid-search for hyperparameter optimization scales exponentially with the
number of hyperparameters (&#8220;curse of dimensionality&#8221;). The gradient-based
optimization of the parameters in GPR does not suffer from this exponential
scaling and is thus considerable faster on this example with 3-dimensional
hyperparameter space. The time for predicting is similar; however, generating
the variance of the predictive distribution of GPR takes considerable longer
than just predicting the mean.</p>
</div>
<div class="section" id="gpr-on-mauna-loa-co2-data">
<h3>1.7.2.3. GPR on Mauna Loa CO2 data<a class="headerlink" href="#gpr-on-mauna-loa-co2-data" title="Permalink to this headline">¶</a></h3>
<p>This example is based on Section 5.4.3 of &#8220;Gaussian Processes for Machine
Learning&#8221; [RW2006]. It illustrates an example of complex kernel engineering and
hyperparameter optimization using gradient ascent on the
log-marginal-likelihood. The data consists of the monthly average atmospheric
CO2 concentrations (in parts per million by volume (ppmv)) collected at the
Mauna Loa Observatory in Hawaii, between 1958 and 1997. The objective is to
model the CO2 concentration as a function of the time t.</p>
<p>The kernel is composed of several terms that are responsible for explaining
different properties of the signal:</p>
<blockquote>
<div><ul class="simple">
<li>a long term, smooth rising trend is to be explained by an RBF kernel. The
RBF kernel with a large length-scale enforces this component to be smooth;
it is not enforced that the trend is rising which leaves this choice to the
GP. The specific length-scale and the amplitude are free hyperparameters.</li>
<li>a seasonal component, which is to be explained by the periodic
ExpSineSquared kernel with a fixed periodicity of 1 year. The length-scale
of this periodic component, controlling its smoothness, is a free parameter.
In order to allow decaying away from exact periodicity, the product with an
RBF kernel is taken. The length-scale of this RBF component controls the
decay time and is a further free parameter.</li>
<li>smaller, medium term irregularities are to be explained by a
RationalQuadratic kernel component, whose length-scale and alpha parameter,
which determines the diffuseness of the length-scales, are to be determined.
According to [RW2006], these irregularities can better be explained by
a RationalQuadratic than an RBF kernel component, probably because it can
accommodate several length-scales.</li>
<li>a &#8220;noise&#8221; term, consisting of an RBF kernel contribution, which shall
explain the correlated noise components such as local weather phenomena,
and a WhiteKernel contribution for the white noise. The relative amplitudes
and the RBF&#8217;s length scale are further free parameters.</li>
</ul>
</div></blockquote>
<p>Maximizing the log-marginal-likelihood after subtracting the target&#8217;s mean
yields the following kernel with an LML of -83.214:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">34.4</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">41.8</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">3.27</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mi">180</span><span class="p">)</span> <span class="o">*</span> <span class="n">ExpSineSquared</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">1.44</span><span class="p">,</span>
                                                   <span class="n">periodicity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">0.446</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RationalQuadratic</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">17.7</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="mf">0.957</span><span class="p">)</span>
<span class="o">+</span> <span class="mf">0.197</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">0.138</span><span class="p">)</span> <span class="o">+</span> <span class="n">WhiteKernel</span><span class="p">(</span><span class="n">noise_level</span><span class="o">=</span><span class="mf">0.0336</span><span class="p">)</span>
</pre></div>
</div>
<p>Thus, most of the target signal (34.4ppm) is explained by a long-term rising
trend (length-scale 41.8 years). The periodic component has an amplitude of
3.27ppm, a decay time of 180 years and a length-scale of 1.44. The long decay
time indicates that we have a locally very close to periodic seasonal
component. The correlated noise has an amplitude of 0.197ppm with a length
scale of 0.138 years and a white-noise contribution of 0.197ppm. Thus, the
overall noise level is very small, indicating that the data can be very well
explained by the model. The figure shows also that the model makes very
confident predictions until around 2015</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_co2.html"><img alt="../_images/plot_gpr_co2_0011.png" src="../_images/plot_gpr_co2_0011.png" /></a>
</div>
</div>
</div>
<div class="section" id="gaussian-process-classification-gpc">
<span id="gpc"></span><h2>1.7.3. Gaussian Process Classification (GPC)<a class="headerlink" href="#gaussian-process-classification-gpc" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcessClassifier</span></tt></a> implements Gaussian processes (GP) for
classification purposes, more specifically for probabilistic classification,
where test predictions take the form of class probabilities.
GaussianProcessClassifier places a GP prior on a latent function <span class="math">f</span>,
which is then squashed through a link function to obtain the probabilistic
classification. The latent function <span class="math">f</span> is a so-called nuisance function,
whose values are not observed and are not relevant by themselves.
Its purpose is to allow a convenient formulation of the model, and <span class="math">f</span>
is removed (integrated out) during prediction. GaussianProcessClassifier
implements the logistic link function, for which the integral cannot be
computed analytically but is easily approximated in the binary case.</p>
<p>In contrast to the regression setting, the posterior of the latent function
<span class="math">f</span> is not Gaussian even for a GP prior since a Gaussian likelihood is
inappropriate for discrete class labels. Rather, a non-Gaussian likelihood
corresponding to the logistic link function (logit) is used.
GaussianProcessClassifier approximates the non-Gaussian posterior with a
Gaussian based on the Laplace approximation. More details can be found in
Chapter 3 of [RW2006].</p>
<p>The GP prior mean is assumed to be zero. The prior&#8217;s
covariance is specified by a passing a <a class="reference internal" href="#gp-kernels"><em>kernel</em></a> object. The
hyperparameters of the kernel are optimized during fitting of
GaussianProcessRegressor by maximizing the log-marginal-likelihood (LML) based
on the passed <tt class="docutils literal"><span class="pre">optimizer</span></tt>. As the LML may have multiple local optima, the
optimizer can be started repeatedly by specifying <tt class="docutils literal"><span class="pre">n_restarts_optimizer</span></tt>. The
first run is always conducted starting from the initial hyperparameter values
of the kernel; subsequent runs are conducted from hyperparameter values
that have been chosen randomly from the range of allowed values.
If the initial hyperparameters should be kept fixed, <cite>None</cite> can be passed as
optimizer.</p>
<p><a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcessClassifier</span></tt></a> supports multi-class classification
by performing either one-versus-rest or one-versus-one based training and
prediction.  In one-versus-rest, one binary Gaussian process classifier is
fitted for each class, which is trained to separate this class from the rest.
In &#8220;one_vs_one&#8221;, one binary Gaussian process classifier is fitted for each pair
of classes, which is trained to separate these two classes. The predictions of
these binary predictors are combined into multi-class predictions. See the
section on <a class="reference internal" href="multiclass.html#multiclass"><em>multi-class classification</em></a> for more details.</p>
<p>In the case of Gaussian process classification, &#8220;one_vs_one&#8221; might be
computationally  cheaper since it has to solve many problems involving only a
subset of the whole training set rather than fewer problems on the whole
dataset. Since Gaussian process classification scales cubically with the size
of the dataset, this might be considerably faster. However, note that
&#8220;one_vs_one&#8221; does not support predicting probability estimates but only plain
predictions. Moreover, note that <a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcessClassifier</span></tt></a> does not
(yet) implement a true multi-class Laplace approximation internally, but
as discussed aboved is based on solving several binary classification tasks
internally, which are combined using one-versus-rest or one-versus-one.</p>
</div>
<div class="section" id="gpc-examples">
<h2>1.7.4. GPC examples<a class="headerlink" href="#gpc-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="probabilistic-predictions-with-gpc">
<h3>1.7.4.1. Probabilistic predictions with GPC<a class="headerlink" href="#probabilistic-predictions-with-gpc" title="Permalink to this headline">¶</a></h3>
<p>This example illustrates the predicted probability of GPC for an RBF kernel
with different choices of the hyperparameters. The first figure shows the
predicted probability of GPC with arbitrarily chosen hyperparameters and with
the hyperparameters corresponding to the maximum log-marginal-likelihood (LML).</p>
<p>While the hyperparameters chosen by optimizing LML have a considerable larger
LML, they perform slightly worse according to the log-loss on test data. The
figure shows that this is because they exhibit a steep change of the class
probabilities at the class boundaries (which is good) but have predicted
probabilities close to 0.5 far away from the class boundaries (which is bad)
This undesirable effect is caused by the Laplace approximation used
internally by GPC.</p>
<p>The second figure shows the log-marginal-likelihood for different choices of
the kernel&#8217;s hyperparameters, highlighting the two choices of the
hyperparameters used in the first figure by black dots.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc.html"><img alt="../_images/plot_gpc_0001.png" src="../_images/plot_gpc_0001.png" /></a>
</div>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc.html"><img alt="../_images/plot_gpc_0011.png" src="../_images/plot_gpc_0011.png" /></a>
</div>
</div>
<div class="section" id="illustration-of-gpc-on-the-xor-dataset">
<h3>1.7.4.2. Illustration of GPC on the XOR dataset<a class="headerlink" href="#illustration-of-gpc-on-the-xor-dataset" title="Permalink to this headline">¶</a></h3>
<p>This example illustrates GPC on XOR data. Compared are a stationary, isotropic
kernel (<a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><tt class="xref py py-class docutils literal"><span class="pre">RBF</span></tt></a>) and a non-stationary kernel (<a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><tt class="xref py py-class docutils literal"><span class="pre">DotProduct</span></tt></a>). On this particular
dataset, the <cite>DotProduct</cite> kernel obtains considerably better results because the
class-boundaries are linear and coincide with the coordinate axes. In practice,
however, stationary kernels such as <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><tt class="xref py py-class docutils literal"><span class="pre">RBF</span></tt></a> often obtain better results.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc_xor.html"><img alt="../_images/plot_gpc_xor_0011.png" src="../_images/plot_gpc_xor_0011.png" /></a>
</div>
</div>
<div class="section" id="gaussian-process-classification-gpc-on-iris-dataset">
<h3>1.7.4.3. Gaussian process classification (GPC) on iris dataset<a class="headerlink" href="#gaussian-process-classification-gpc-on-iris-dataset" title="Permalink to this headline">¶</a></h3>
<p>This example illustrates the predicted probability of GPC for an isotropic
and anisotropic RBF kernel on a two-dimensional version for the iris-dataset.
This illustrates the applicability of GPC to non-binary classification.
The anisotropic RBF kernel obtains slightly higher log-marginal-likelihood by
assigning different length-scales to the two feature dimensions.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpc_iris.html"><img alt="../_images/plot_gpc_iris_0011.png" src="../_images/plot_gpc_iris_0011.png" /></a>
</div>
</div>
</div>
<div class="section" id="kernels-for-gaussian-processes">
<span id="gp-kernels"></span><h2>1.7.5. Kernels for Gaussian Processes<a class="headerlink" href="#kernels-for-gaussian-processes" title="Permalink to this headline">¶</a></h2>
<p>Kernels (also called &#8220;covariance functions&#8221; in the context of GPs) are a crucial
ingredient of GPs which determine the shape of prior and posterior of the GP.
They encode the assumptions on the function being learned by defining the &#8220;similarity&#8221;
of two datapoints combined with the assumption that similar datapoints should
have similar target values. Two categories of kernels can be distinguished:
stationary kernels depend only on the distance of two datapoints and not on their
absolute values <span class="math">k(x_i, x_j)= k(d(x_i, x_j))</span> and are thus invariant to
translations in the input space, while non-stationary kernels
depend also on the specific values of the datapoints. Stationary kernels can further
be subdivided into isotropic and anisotropic kernels, where isotropic kernels are
also invariant to rotations in the input space. For more details, we refer to
Chapter 4 of [RW2006].</p>
<div class="section" id="gaussian-process-kernel-api">
<h3>1.7.5.1. Gaussian Process Kernel API<a class="headerlink" href="#gaussian-process-kernel-api" title="Permalink to this headline">¶</a></h3>
<p>The main usage of a <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> is to compute the GP&#8217;s covariance between
datapoints. For this, the method <tt class="docutils literal"><span class="pre">__call__</span></tt> of the kernel can be called. This
method can either be used to compute the &#8220;auto-covariance&#8221; of all pairs of
datapoints in a 2d array X, or the &#8220;cross-covariance&#8221; of all combinations
of datapoints of a 2d array X with datapoints in a 2d array Y. The following
identity holds true for all kernels k (except for the <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.WhiteKernel.html#sklearn.gaussian_process.kernels.WhiteKernel" title="sklearn.gaussian_process.kernels.WhiteKernel"><tt class="xref py py-class docutils literal"><span class="pre">WhiteKernel</span></tt></a>):
<tt class="docutils literal"><span class="pre">k(X)</span> <span class="pre">==</span> <span class="pre">K(X,</span> <span class="pre">Y=X)</span></tt></p>
<p>If only the diagonal of the auto-covariance is being used, the method <tt class="docutils literal"><span class="pre">diag()</span></tt>
of a kernel can be called, which is more computationally efficient than the
equivalent call to <tt class="docutils literal"><span class="pre">__call__</span></tt>: <tt class="docutils literal"><span class="pre">np.diag(k(X,</span> <span class="pre">X))</span> <span class="pre">==</span> <span class="pre">k.diag(X)</span></tt></p>
<p>Kernels are parameterized by a vector <span class="math">\theta</span> of hyperparameters. These
hyperparameters can for instance control length-scales or periodicity of a
kernel (see below). All kernels support computing analytic gradients of
of the kernel&#8217;s auto-covariance with respect to <span class="math">\theta</span> via setting
<tt class="docutils literal"><span class="pre">eval_gradient=True</span></tt> in the <tt class="docutils literal"><span class="pre">__call__</span></tt> method. This gradient is used by the
Gaussian process (both regressor and classifier) in computing the gradient
of the log-marginal-likelihood, which in turn is used to determine the
value of <span class="math">\theta</span>, which maximizes the log-marginal-likelihood,  via
gradient ascent. For each hyperparameter, the initial value and the
bounds need to be specified when creating an instance of the kernel. The
current value of <span class="math">\theta</span> can be get and set via the property
<tt class="docutils literal"><span class="pre">theta</span></tt> of the kernel object. Moreover, the bounds of the hyperparameters can be
accessed by the property <tt class="docutils literal"><span class="pre">bounds</span></tt> of the kernel. Note that both properties
(theta and bounds) return log-transformed values of the internally used values
since those are typically more amenable to gradient-based optimization.
The specification of each hyperparameter is stored in the form of an instance of
<a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Hyperparameter.html#sklearn.gaussian_process.kernels.Hyperparameter" title="sklearn.gaussian_process.kernels.Hyperparameter"><tt class="xref py py-class docutils literal"><span class="pre">Hyperparameter</span></tt></a> in the respective kernel. Note that a kernel using a
hyperparameter with name &#8220;x&#8221; must have the attributes self.x and self.x_bounds.</p>
<p>The abstract base class for all kernels is <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a>. Kernel implements a
similar interface as <tt class="xref py py-class docutils literal"><span class="pre">Estimator</span></tt>, providing the methods <tt class="docutils literal"><span class="pre">get_params()</span></tt>,
<tt class="docutils literal"><span class="pre">set_params()</span></tt>, and <tt class="docutils literal"><span class="pre">clone()</span></tt>. This allows setting kernel values also via
meta-estimators such as <tt class="xref py py-class docutils literal"><span class="pre">Pipeline</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">GridSearch</span></tt>. Note that due to the nested
structure of kernels (by applying kernel operators, see below), the names of
kernel parameters might become relatively complicated. In general, for a
binary kernel operator, parameters of the left operand are prefixed with <tt class="docutils literal"><span class="pre">k1__</span></tt>
and parameters of the right operand with <tt class="docutils literal"><span class="pre">k2__</span></tt>. An additional convenience
method is <tt class="docutils literal"><span class="pre">clone_with_theta(theta)</span></tt>, which returns a cloned version of the
kernel but with the hyperparameters set to <tt class="docutils literal"><span class="pre">theta</span></tt>. An illustrative example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.gaussian_process.kernels</span> <span class="kn">import</span> <span class="n">ConstantKernel</span><span class="p">,</span> <span class="n">RBF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">ConstantKernel</span><span class="p">(</span><span class="n">constant_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">constant_value_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span> <span class="o">+</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hyperparameter</span> <span class="ow">in</span> <span class="n">kernel</span><span class="o">.</span><span class="n">hyperparameters</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">hyperparameter</span><span class="p">)</span>
<span class="go">Hyperparameter(name=&#39;k1__k1__constant_value&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="go">Hyperparameter(name=&#39;k1__k2__length_scale&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="go">Hyperparameter(name=&#39;k2__length_scale&#39;, value_type=&#39;numeric&#39;, bounds=array([[  0.,  10.]]), n_elements=1, fixed=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">params</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> : </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
<span class="go">k1 : 1**2 * RBF(length_scale=0.5)</span>
<span class="go">k1__k1 : 1**2</span>
<span class="go">k1__k1__constant_value : 1.0</span>
<span class="go">k1__k1__constant_value_bounds : (0.0, 10.0)</span>
<span class="go">k1__k2 : RBF(length_scale=0.5)</span>
<span class="go">k1__k2__length_scale : 0.5</span>
<span class="go">k1__k2__length_scale_bounds : (0.0, 10.0)</span>
<span class="go">k2 : RBF(length_scale=2)</span>
<span class="go">k2__length_scale : 2.0</span>
<span class="go">k2__length_scale_bounds : (0.0, 10.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>  <span class="c"># Note: log-transformed</span>
<span class="go">[ 0.         -0.69314718  0.69314718]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>  <span class="c"># Note: log-transformed</span>
<span class="go">[[       -inf  2.30258509]</span>
<span class="go"> [       -inf  2.30258509]</span>
<span class="go"> [       -inf  2.30258509]]</span>
</pre></div>
</div>
<p>All Gaussian process kernels are interoperable with <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics.pairwise</span></tt></a>
and vice versa: instances of subclasses of <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> can be passed as
<tt class="docutils literal"><span class="pre">metric</span></tt> to pairwise_kernels`` from <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics.pairwise</span></tt></a>. Moreover,
kernel functions from pairwise can be used as GP kernels by using the wrapper
class <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.PairwiseKernel.html#sklearn.gaussian_process.kernels.PairwiseKernel" title="sklearn.gaussian_process.kernels.PairwiseKernel"><tt class="xref py py-class docutils literal"><span class="pre">PairwiseKernel</span></tt></a>. The only caveat is that the gradient of
the hyperparameters is not analytic but numeric and all those kernels support
only isotropic distances. The parameter <tt class="docutils literal"><span class="pre">gamma</span></tt> is considered to be a
hyperparameter and may be optimized. The other kernel parameters are set
directly at initialization and are kept fixed.</p>
</div>
<div class="section" id="basic-kernels">
<h3>1.7.5.2. Basic kernels<a class="headerlink" href="#basic-kernels" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.ConstantKernel.html#sklearn.gaussian_process.kernels.ConstantKernel" title="sklearn.gaussian_process.kernels.ConstantKernel"><tt class="xref py py-class docutils literal"><span class="pre">ConstantKernel</span></tt></a> kernel can be used as part of a <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Product.html#sklearn.gaussian_process.kernels.Product" title="sklearn.gaussian_process.kernels.Product"><tt class="xref py py-class docutils literal"><span class="pre">Product</span></tt></a>
kernel where it scales the magnitude of the other factor (kernel) or as part
of a <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Sum.html#sklearn.gaussian_process.kernels.Sum" title="sklearn.gaussian_process.kernels.Sum"><tt class="xref py py-class docutils literal"><span class="pre">Sum</span></tt></a> kernel, where it modifies the mean of the Gaussian process.
It depends on a parameter <span class="math">constant\_value</span>. It is defined as:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = constant\_value \;\forall\; x_1, x_2</span></p>
</div><p>The main use-case of the <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.WhiteKernel.html#sklearn.gaussian_process.kernels.WhiteKernel" title="sklearn.gaussian_process.kernels.WhiteKernel"><tt class="xref py py-class docutils literal"><span class="pre">WhiteKernel</span></tt></a> kernel is as part of a
sum-kernel where it explains the noise-component of the signal. Tuning its
parameter <span class="math">noise\_level</span> corresponds to estimating the noise-level.
It is defined as:e</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = noise\_level \text{ if } x_i == x_j \text{ else } 0</span></p>
</div></div>
<div class="section" id="kernel-operators">
<h3>1.7.5.3. Kernel operators<a class="headerlink" href="#kernel-operators" title="Permalink to this headline">¶</a></h3>
<p>Kernel operators take one or two base kernels and combine them into a new
kernel. The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Sum.html#sklearn.gaussian_process.kernels.Sum" title="sklearn.gaussian_process.kernels.Sum"><tt class="xref py py-class docutils literal"><span class="pre">Sum</span></tt></a> kernel takes two kernels <span class="math">k1</span> and <span class="math">k2</span>
and combines them via <span class="math">k_{sum}(X, Y) = k1(X, Y) + k2(X, Y)</span>.
The  <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Product.html#sklearn.gaussian_process.kernels.Product" title="sklearn.gaussian_process.kernels.Product"><tt class="xref py py-class docutils literal"><span class="pre">Product</span></tt></a> kernel takes two kernels <span class="math">k1</span> and <span class="math">k2</span>
and combines them via <span class="math">k_{product}(X, Y) = k1(X, Y) * k2(X, Y)</span>.
The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Exponentiation.html#sklearn.gaussian_process.kernels.Exponentiation" title="sklearn.gaussian_process.kernels.Exponentiation"><tt class="xref py py-class docutils literal"><span class="pre">Exponentiation</span></tt></a> kernel takes one base kernel and a scalar parameter
<span class="math">exponent</span> and combines them via
<span class="math">k_{exp}(X, Y) = k(X, Y)^\text{exponent}</span>.</p>
</div>
<div class="section" id="radial-basis-function-rbf-kernel">
<h3>1.7.5.4. Radial-basis function (RBF) kernel<a class="headerlink" href="#radial-basis-function-rbf-kernel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><tt class="xref py py-class docutils literal"><span class="pre">RBF</span></tt></a> kernel is a stationary kernel. It is also known as the &#8220;squared
exponential&#8221; kernel. It is parameterized by a length-scale parameter <span class="math">l&gt;0</span>, which
can either be a scalar (isotropic variant of the kernel) or a vector with the same
number of dimensions as the inputs <span class="math">x</span> (anisotropic variant of the kernel).
The kernel is given by:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \text{exp}\left(-\frac{1}{2} d(x_i / l, x_j / l)^2\right)</span></p>
</div><p>This kernel is infinitely differentiable, which implies that GPs with this
kernel as covariance function have mean square derivatives of all orders, and are thus
very smooth. The prior and posterior of a GP resulting from an RBF kernel are shown in
the following figure:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="../_images/plot_gpr_prior_posterior_0001.png" src="../_images/plot_gpr_prior_posterior_0001.png" /></a>
</div>
</div>
<div class="section" id="matern-kernel">
<h3>1.7.5.5. Matérn kernel<a class="headerlink" href="#matern-kernel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern" title="sklearn.gaussian_process.kernels.Matern"><tt class="xref py py-class docutils literal"><span class="pre">Matern</span></tt></a> kernel is a stationary kernel and a generalization of the
<a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><tt class="xref py py-class docutils literal"><span class="pre">RBF</span></tt></a> kernel. It has an additional parameter <span class="math">\nu</span> which controls
the smoothness of the resulting function. It is parameterized by a length-scale parameter <span class="math">l&gt;0</span>, which can either be a scalar (isotropic variant of the kernel) or a vector with the same number of dimensions as the inputs <span class="math">x</span> (anisotropic variant of the kernel). The kernel is given by:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2\frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\gamma\sqrt{2\nu} d(x_i / l, x_j / l)\Bigg)^\nu K_\nu\Bigg(\gamma\sqrt{2\nu} d(x_i / l, x_j / l)\Bigg),</span></p>
</div><p>As <span class="math">\nu\rightarrow\infty</span>, the Matérn kernel converges to the RBF kernel.
When <span class="math">\nu = 1/2</span>, the Matérn kernel becomes identical to the absolute
exponential kernel, i.e.,</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \exp \Bigg(-\gamma d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{1}{2}</span></p>
</div><p>In particular, <span class="math">\nu = 3/2</span>:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \Bigg(1 + \gamma \sqrt{3} d(x_i / l, x_j / l)\Bigg) \exp \Bigg(-\gamma \sqrt{3}d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{3}{2}</span></p>
</div><p>and <span class="math">\nu = 5/2</span>:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma^2 \Bigg(1 + \gamma \sqrt{5}d(x_i / l, x_j / l) +\frac{5}{3} \gamma^2d(x_i / l, x_j / l)^2 \Bigg) \exp \Bigg(-\gamma \sqrt{5}d(x_i / l, x_j / l) \Bigg) \quad \quad \nu= \tfrac{5}{2}</span></p>
</div><p>are popular choices for learning functions that are not infinitely
differentiable (as assumed by the RBF kernel) but at least once (<span class="math">\nu =
3/2</span>) or twice differentiable (<span class="math">\nu = 5/2</span>).</p>
<p>The flexibility of controlling the smoothness of the learned function via <span class="math">\nu</span>
allows adapting to the properties of the true underlying functional relation.
The prior and posterior of a GP resulting from a Matérn kernel are shown in
the following figure:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="../_images/plot_gpr_prior_posterior_0041.png" src="../_images/plot_gpr_prior_posterior_0041.png" /></a>
</div>
<p>See [RW2006], pp84 for further details regarding the
different variants of the Matérn kernel.</p>
</div>
<div class="section" id="rational-quadratic-kernel">
<h3>1.7.5.6. Rational quadratic kernel<a class="headerlink" href="#rational-quadratic-kernel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RationalQuadratic.html#sklearn.gaussian_process.kernels.RationalQuadratic" title="sklearn.gaussian_process.kernels.RationalQuadratic"><tt class="xref py py-class docutils literal"><span class="pre">RationalQuadratic</span></tt></a> kernel can be seen as a scale mixture (an infinite sum)
of <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.RBF.html#sklearn.gaussian_process.kernels.RBF" title="sklearn.gaussian_process.kernels.RBF"><tt class="xref py py-class docutils literal"><span class="pre">RBF</span></tt></a> kernels with different characteristic length-scales. It is parameterized
by a length-scale parameter <span class="math">l&gt;0</span> and a scale mixture parameter  <span class="math">\alpha&gt;0</span>
Only the isotropic variant where <span class="math">l</span> is a scalar is supported at the moment.
The kernel is given by:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2}{2\alpha l^2}\right)^\alpha</span></p>
</div><p>The prior and posterior of a GP resulting from an RBF kernel are shown in
the following figure:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="../_images/plot_gpr_prior_posterior_0011.png" src="../_images/plot_gpr_prior_posterior_0011.png" /></a>
</div>
</div>
<div class="section" id="exp-sine-squared-kernel">
<h3>1.7.5.7. Exp-Sine-Squared kernel<a class="headerlink" href="#exp-sine-squared-kernel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.ExpSineSquared.html#sklearn.gaussian_process.kernels.ExpSineSquared" title="sklearn.gaussian_process.kernels.ExpSineSquared"><tt class="xref py py-class docutils literal"><span class="pre">ExpSineSquared</span></tt></a> kernel allows modeling periodic functions.
It is parameterized by a length-scale parameter <span class="math">l&gt;0</span> and a periodicity parameter
<span class="math">p&gt;0</span>. Only the isotropic variant where <span class="math">l</span> is a scalar is supported at the moment.
The kernel is given by:</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \text{exp}\left(-2 \text{sin}(\pi / p * d(x_i, x_j)) / l\right)^2</span></p>
</div><p>The prior and posterior of a GP resulting from an ExpSineSquared kernel are shown in
the following figure:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="../_images/plot_gpr_prior_posterior_0021.png" src="../_images/plot_gpr_prior_posterior_0021.png" /></a>
</div>
</div>
<div class="section" id="dot-product-kernel">
<h3>1.7.5.8. Dot-Product kernel<a class="headerlink" href="#dot-product-kernel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><tt class="xref py py-class docutils literal"><span class="pre">DotProduct</span></tt></a> kernel is non-stationary and can be obtained from linear regression
by putting <span class="math">N(0, 1)</span> priors on the coefficients of <span class="math">x_d (d = 1, . . . , D)</span> and
a prior of <span class="math">N(0, \sigma_0^2)</span> on the bias. The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><tt class="xref py py-class docutils literal"><span class="pre">DotProduct</span></tt></a> kernel is invariant to a rotation
of the coordinates about the origin, but not translations.
It is parameterized by a parameter <span class="math">\sigma_0^2</span>. For <span class="math">\sigma_0^2 = 0</span>, the kernel
is called the homogeneous linear kernel, otherwise it is inhomogeneous. The kernel is given by</p>
<div class="math">
<p><span class="math">k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j</span></p>
</div><p>The <a class="reference internal" href="generated/sklearn.gaussian_process.kernels.DotProduct.html#sklearn.gaussian_process.kernels.DotProduct" title="sklearn.gaussian_process.kernels.DotProduct"><tt class="xref py py-class docutils literal"><span class="pre">DotProduct</span></tt></a> kernel is commonly combined with exponentiation. An example with exponent 2 is
shown in the following figure:</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/gaussian_process/plot_gpr_prior_posterior.html"><img alt="../_images/plot_gpr_prior_posterior_0031.png" src="../_images/plot_gpr_prior_posterior_0031.png" /></a>
</div>
</div>
</div>
<div class="section" id="legacy-gaussian-processes">
<h2>1.7.6. Legacy Gaussian Processes<a class="headerlink" href="#legacy-gaussian-processes" title="Permalink to this headline">¶</a></h2>
<p>In this section, the implementation of Gaussian processes used in sklearn until
release 0.16.1 is described. Note that this implementation is deprecated and
will be removed in version 0.18.</p>
<div class="section" id="an-introductory-regression-example">
<h3>1.7.6.1. An introductory regression example<a class="headerlink" href="#an-introductory-regression-example" title="Permalink to this headline">¶</a></h3>
<p>Say we want to surrogate the function <span class="math">g(x) = x \sin(x)</span>. To do so,
the function is evaluated onto a design of experiments. Then, we define a
GaussianProcess model whose regression and correlation models might be
specified using additional kwargs, and ask for the model to be fitted to the
data. Depending on the number of parameters provided at instantiation, the
fitting procedure may recourse to maximum likelihood estimation for the
parameters or alternatively it uses the given parameters.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">gaussian_process</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span> <span class="o">=</span> <span class="n">gaussian_process</span><span class="o">.</span><span class="n">GaussianProcess</span><span class="p">(</span><span class="n">theta0</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">thetaL</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">thetaU</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">GaussianProcess(beta0=None, corr=&lt;function squared_exponential at 0x...&gt;,</span>
<span class="go">        normalize=True, nugget=array(2.22...-15),</span>
<span class="go">        optimizer=&#39;fmin_cobyla&#39;, random_start=1, random_state=...</span>
<span class="go">        regr=&lt;function constant at 0x...&gt;, storage_mode=&#39;full&#39;,</span>
<span class="go">        theta0=array([[ 0.01]]), thetaL=array([[ 0.0001]]),</span>
<span class="go">        thetaU=array([[ 0.1]]), verbose=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span><span class="p">,</span> <span class="n">sigma2_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eval_MSE</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fitting-noisy-data">
<h3>1.7.6.2. Fitting Noisy Data<a class="headerlink" href="#fitting-noisy-data" title="Permalink to this headline">¶</a></h3>
<p>When the data to be fit includes noise, the Gaussian process model can be
used by specifying the variance of the noise for each point.
<a class="reference internal" href="generated/sklearn.gaussian_process.GaussianProcess.html#sklearn.gaussian_process.GaussianProcess" title="sklearn.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a> takes a parameter <tt class="docutils literal"><span class="pre">nugget</span></tt> which
is added to the diagonal of the correlation matrix between training points:
in general this is a type of Tikhonov regularization.  In the special case
of a squared-exponential correlation function, this normalization is
equivalent to specifying a fractional variance in the input.  That is</p>
<div class="math">
<p><span class="math">\mathrm{nugget}_i = \left[\frac{\sigma_i}{y_i}\right]^2</span></p>
</div><p>With <tt class="docutils literal"><span class="pre">nugget</span></tt> and <tt class="docutils literal"><span class="pre">corr</span></tt> properly set, Gaussian Processes can be
used to robustly recover an underlying function from noisy data.</p>
</div>
<div class="section" id="mathematical-formulation">
<h3>1.7.6.3. Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-initial-assumption">
<h4>1.7.6.3.1. The initial assumption<a class="headerlink" href="#the-initial-assumption" title="Permalink to this headline">¶</a></h4>
<p>Suppose one wants to model the output of a computer experiment, say a
mathematical function:</p>
<div class="math">
<p><span class="math">g: &amp; \mathbb{R}^{n_{\rm features}} \rightarrow \mathbb{R} \\
   &amp; X \mapsto y = g(X)</span></p>
</div><p>GPML starts with the assumption that this function is <em>a</em> conditional sample
path of <em>a</em> Gaussian process <span class="math">G</span> which is additionally assumed to read as
follows:</p>
<div class="math">
<p><span class="math">G(X) = f(X)^T \beta + Z(X)</span></p>
</div><p>where <span class="math">f(X)^T \beta</span> is a linear regression model and <span class="math">Z(X)</span> is a
zero-mean Gaussian process with a fully stationary covariance function:</p>
<div class="math">
<p><span class="math">C(X, X') = \sigma^2 R(|X - X'|)</span></p>
</div><p><span class="math">\sigma^2</span> being its variance and <span class="math">R</span> being the correlation
function which solely depends on the absolute relative distance between each
sample, possibly featurewise (this is the stationarity assumption).</p>
<p>From this basic formulation, note that GPML is nothing but an extension of a
basic least squares linear regression problem:</p>
<div class="math">
<p><span class="math">g(X) \approx f(X)^T \beta</span></p>
</div><p>Except we additionally assume some spatial coherence (correlation) between the
samples dictated by the correlation function. Indeed, ordinary least squares
assumes the correlation model <span class="math">R(|X - X'|)</span> is one when <span class="math">X = X'</span>
and zero otherwise : a <em>dirac</em> correlation model &#8211; sometimes referred to as a
<em>nugget</em> correlation model in the kriging literature.</p>
</div>
<div class="section" id="the-best-linear-unbiased-prediction-blup">
<h4>1.7.6.3.2. The best linear unbiased prediction (BLUP)<a class="headerlink" href="#the-best-linear-unbiased-prediction-blup" title="Permalink to this headline">¶</a></h4>
<p>We now derive the <em>best linear unbiased prediction</em> of the sample path
<span class="math">g</span> conditioned on the observations:</p>
<div class="math">
<p><span class="math">\hat{G}(X) = G(X | y_1 = g(X_1), ...,
                            y_{n_{\rm samples}} = g(X_{n_{\rm samples}}))</span></p>
</div><p>It is derived from its <em>given properties</em>:</p>
<ul class="simple">
<li>It is linear (a linear combination of the observations)</li>
</ul>
<div class="math">
<p><span class="math">\hat{G}(X) \equiv a(X)^T y</span></p>
</div><ul class="simple">
<li>It is unbiased</li>
</ul>
<div class="math">
<p><span class="math">\mathbb{E}[G(X) - \hat{G}(X)] = 0</span></p>
</div><ul class="simple">
<li>It is the best (in the Mean Squared Error sense)</li>
</ul>
<div class="math">
<p><span class="math">\hat{G}(X)^* = \arg \min\limits_{\hat{G}(X)} \;
                                        \mathbb{E}[(G(X) - \hat{G}(X))^2]</span></p>
</div><p>So that the optimal weight vector <span class="math">a(X)</span> is solution of the following
equality constrained optimization problem:</p>
<div class="math">
<p><span class="math">a(X)^* = \arg \min\limits_{a(X)} &amp; \; \mathbb{E}[(G(X) - a(X)^T y)^2] \\
                   {\rm s. t.} &amp; \; \mathbb{E}[G(X) - a(X)^T y] = 0</span></p>
</div><p>Rewriting this constrained optimization problem in the form of a Lagrangian and
looking further for the first order optimality conditions to be satisfied, one
ends up with a closed form expression for the sought predictor &#8211; see
references for the complete proof.</p>
<p>In the end, the BLUP is shown to be a Gaussian random variate with mean:</p>
<div class="math">
<p><span class="math">\mu_{\hat{Y}}(X) = f(X)^T\,\hat{\beta} + r(X)^T\,\gamma</span></p>
</div><p>and variance:</p>
<div class="math">
<p><span class="math">\sigma_{\hat{Y}}^2(X) = \sigma_{Y}^2\,
( 1
- r(X)^T\,R^{-1}\,r(X)
+ u(X)^T\,(F^T\,R^{-1}\,F)^{-1}\,u(X)
)</span></p>
</div><p>where we have introduced:</p>
<ul class="simple">
<li>the correlation matrix whose terms are defined wrt the autocorrelation
function and its built-in parameters <span class="math">\theta</span>:</li>
</ul>
<div class="math">
<p><span class="math">R_{i\,j} = R(|X_i - X_j|, \theta), \; i,\,j = 1, ..., m</span></p>
</div><ul class="simple">
<li>the vector of cross-correlations between the point where the prediction is
made and the points in the DOE:</li>
</ul>
<div class="math">
<p><span class="math">r_i = R(|X - X_i|, \theta), \; i = 1, ..., m</span></p>
</div><ul class="simple">
<li>the regression matrix (eg the Vandermonde matrix if <span class="math">f</span> is a polynomial
basis):</li>
</ul>
<div class="math">
<p><span class="math">F_{i\,j} = f_i(X_j), \; i = 1, ..., p, \, j = 1, ..., m</span></p>
</div><ul class="simple">
<li>the generalized least square regression weights:</li>
</ul>
<div class="math">
<p><span class="math">\hat{\beta} =(F^T\,R^{-1}\,F)^{-1}\,F^T\,R^{-1}\,Y</span></p>
</div><ul class="simple">
<li>and the vectors:</li>
</ul>
<div class="math">
<p><span class="math">\gamma &amp; = R^{-1}(Y - F\,\hat{\beta}) \\
u(X) &amp; = F^T\,R^{-1}\,r(X) - f(X)</span></p>
</div><p>It is important to notice that the probabilistic response of a Gaussian Process
predictor is fully analytic and mostly relies on basic linear algebra
operations. More precisely the mean prediction is the sum of two simple linear
combinations (dot products), and the variance requires two matrix inversions,
but the correlation matrix can be decomposed only once using a Cholesky
decomposition algorithm.</p>
</div>
<div class="section" id="the-empirical-best-linear-unbiased-predictor-eblup">
<h4>1.7.6.3.3. The empirical best linear unbiased predictor (EBLUP)<a class="headerlink" href="#the-empirical-best-linear-unbiased-predictor-eblup" title="Permalink to this headline">¶</a></h4>
<p>Until now, both the autocorrelation and regression models were assumed given.
In practice however they are never known in advance so that one has to make
(motivated) empirical choices for these models <a class="reference internal" href="#correlation-models"><em>Correlation Models</em></a>.</p>
<p>Provided these choices are made, one should estimate the remaining unknown
parameters involved in the BLUP. To do so, one uses the set of provided
observations in conjunction with some inference technique. The present
implementation, which is based on the DACE&#8217;s Matlab toolbox uses the <em>maximum
likelihood estimation</em> technique &#8211; see DACE manual in references for the
complete equations. This maximum likelihood estimation problem is turned into
a global optimization problem onto the autocorrelation parameters. In the
present implementation, this global optimization is solved by means of the
fmin_cobyla optimization function from scipy.optimize. In the case of
anisotropy however, we provide an implementation of Welch&#8217;s componentwise
optimization algorithm &#8211; see references.</p>
</div>
</div>
<div class="section" id="correlation-models">
<span id="id7"></span><h3>1.7.6.4. Correlation Models<a class="headerlink" href="#correlation-models" title="Permalink to this headline">¶</a></h3>
<p>Common correlation models matches some famous SVM&#8217;s kernels because they are
mostly built on equivalent assumptions. They must fulfill Mercer&#8217;s conditions
and should additionally remain stationary. Note however, that the choice of the
correlation model should be made in agreement with the known properties of the
original experiment from which the observations come. For instance:</p>
<ul class="simple">
<li>If the original experiment is known to be infinitely differentiable (smooth),
then one should use the <em>squared-exponential correlation model</em>.</li>
<li>If it&#8217;s not, then one should rather use the <em>exponential correlation model</em>.</li>
<li>Note also that there exists a correlation model that takes the degree of
derivability as input: this is the Matern correlation model, but it&#8217;s not
implemented here (TODO).</li>
</ul>
<p>For a more detailed discussion on the selection of appropriate correlation
models, see the book by Rasmussen &amp; Williams in references.</p>
</div>
<div class="section" id="regression-models">
<span id="id8"></span><h3>1.7.6.5. Regression Models<a class="headerlink" href="#regression-models" title="Permalink to this headline">¶</a></h3>
<p>Common linear regression models involve zero- (constant), first- and
second-order polynomials. But one may specify its own in the form of a Python
function that takes the features X as input and that returns a vector
containing the values of the functional set. The only constraint is that the
number of functions must not exceed the number of available observations so
that the underlying regression problem is not <em>underdetermined</em>.</p>
</div>
<div class="section" id="implementation-details">
<h3>1.7.6.6. Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>The implementation is based on a translation of the DACE Matlab
toolbox.</p>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://www2.imm.dtu.dk/~hbn/dace/">DACE, A Matlab Kriging Toolbox</a> S Lophaven, HB Nielsen, J
Sondergaard 2002,</li>
<li>W.J. Welch, R.J. Buck, J. Sacks, H.P. Wynn, T.J. Mitchell, and M.D.
Morris (1992). Screening, predicting, and computer experiments.
Technometrics, 34(1) 15&#8211;25.</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../_sources/modules/gaussian_process.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="neighbors.html">Previous
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>